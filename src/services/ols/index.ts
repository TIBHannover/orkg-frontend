import { Ontology, OntologyTerm, OptionType } from 'components/Autocomplete/types';
import { AUTOCOMPLETE_SOURCE } from 'constants/autocompleteSources';
import { env } from 'next-runtime-env';
import createClient from 'openapi-fetch';
import type { paths } from 'services/ols/schema'; // generated by openapi-typescript
import { EntityType, OntologyElement, OntologyEntityResponse } from 'services/ols/types';
import type { GroupBase, OptionsOrGroups } from 'react-select';

/**
 * OLS API is 0 indexed pages
 */
export const olsBaseUrl = env('NEXT_PUBLIC_OLS_BASE_URL');

export type AdditionalType = {
    page: number;
};

const PAGE_SIZE = 12;

const client = createClient<paths>({
    baseUrl: olsBaseUrl,
    querySerializer: {
        allowReserved: true, // the facetFields param is reserved
        array: {
            style: 'pipeDelimited',
            explode: true,
        },
        object: {
            style: 'form',
            explode: true,
        },
    },
});

export const selectEntities = async ({
    page = 0,
    pageSize = 10,
    type = 'individual',
    q = '',
    ontologies = [],
}: {
    page?: number;
    pageSize?: number;
    type?: string;
    q?: string;
    ontologies?: string[];
}) => {
    const { data } = await client.GET('/api/v2/entities', {
        params: {
            query: {
                pageable: {
                    page,
                    size: pageSize,
                },
                facetFields: 'ontologyId+type',
                ontologyId: encodeURIComponent(ontologies.join(',')),
                type,
                search: encodeURIComponent(q),
                searchProperties: {},
            },
        },
    });

    const options: OptionType[] = [];

    if (data) {
        const { elements } = data;
        if (elements && elements.length > 0) {
            for (const item of elements as unknown as EntityType[]) {
                if (item.ontologyPreferredPrefix && item.ontologyId) {
                    options.push({
                        id: item.short_form,
                        label: item.label?.[0] ?? item.ontologyId,
                        ...(item.iri ? { uri: item.iri } : {}),
                        ...(item.description && item.description.length > 0 ? { description: item.description[0] } : {}),
                        ...(item.ontologyPreferredPrefix && item.ontologyId
                            ? { ontology: item.ontologyPreferredPrefix, statements: [], tooltipData: [] }
                            : {}),
                        external: true,
                        source: AUTOCOMPLETE_SOURCE.OLS_API,
                    });
                }
            }
        }
        return { options, hasMore: !((data?.totalPages || 0) <= (data?.page || 0)) };
    }
    return { options, hasMore: false };
};

export const getOntologies = async ({ page = 0, _value = '' }) => {
    const value = _value.trim();
    const _pageSize = value.length >= 1 ? 1000 : PAGE_SIZE;
    let options: Ontology[] = [];
    const { data } = await client.GET('/api/v2/ontologies', {
        params: {
            query: {
                pageable: {
                    page,
                    size: _pageSize,
                },
                searchProperties: {},
            },
        },
    });
    if (data) {
        const { elements } = data;
        if (elements && elements.length > 0) {
            for (const item of elements as unknown as OntologyElement[]) {
                options.push({
                    shortLabel: item.preferredPrefix,
                    id: item.ontologyId,
                    label: item.title,
                    ...(item.baseUri && item.baseUri.length > 0 ? { uri: item.baseUri[0] } : {}),
                    ...(item.description ? { description: item.description } : {}),
                    external: true,
                    source: AUTOCOMPLETE_SOURCE.OLS_API,
                });
            }
            // The search is not working as expected, so we filter the options manually
            if (value.length >= 1) {
                options = options.filter(
                    (option) =>
                        option.description?.toLowerCase()?.includes(value.toLowerCase()) ||
                        option.id?.toLowerCase()?.includes(value.toLowerCase()) ||
                        option.shortLabel?.toLowerCase()?.includes(value.toLowerCase()) ||
                        option.label?.toLowerCase()?.includes(value.toLowerCase()),
                );
            }
        }
        return { options, hasMore: !((data?.totalPages || 0) <= (data?.page || 0)) };
    }
    return { options: [], hasMore: false };
};

export const loadOntologiesOptions = async (
    search: string,
    prevOptions: OptionsOrGroups<Ontology, GroupBase<Ontology>>,
    additional: AdditionalType | undefined,
) => {
    try {
        const result = await getOntologies({ page: additional?.page ?? 0, _value: search });
        const { options, hasMore } = result;

        return {
            options: options as Ontology[],
            hasMore,
            additional: {
                page: (additional?.page ?? 0) + 1,
            },
        };
    } catch (err) {
        console.error(err);
        return {
            options: prevOptions,
            hasMore: false,
            additional: {
                page: 0,
            },
        };
    }
};

export type EntityPath = 'individuals' | 'classes' | 'properties' | 'entities';
type AllPaths = Extract<keyof paths, `/api/v2/ontologies/${string}/${EntityPath}`>;

export const getOntologyEntities = async ({
    ontology_id = '',
    page = 0,
    pageSize = 10,
    type = 'individuals',
}: {
    ontology_id: string;
    page: number;
    pageSize: number;
    type: EntityPath;
}) => {
    const options: OntologyTerm[] = [];
    const path = `/api/v2/ontologies/{onto}/{type}` as const as AllPaths;
    const { data } = await client.GET(path, {
        params: {
            query: {
                pageable: { page, size: pageSize },
                searchProperties: {},
            },
            path: {
                onto: ontology_id,
                type,
            },
        },
    });

    if (data) {
        const { elements } = data;
        if (elements && elements.length > 0) {
            for (const item of elements as unknown as OntologyEntityResponse[]) {
                options.push({
                    label: item.label?.[0] ?? item.ontologyId,
                    id: item.shortForm,
                    ...(item.iri ? { uri: item.iri } : {}),
                    ...(item.definition && item.definition.length > 0
                        ? {
                              description: typeof item.definition[0] === 'string' ? item.definition[0] : item.definition[0].value,
                          }
                        : {}),
                    external: true,
                    source: 'ols-api',
                    ontology: item.ontologyPreferredPrefix,
                    shortLabel: item.shortForm,
                    tooltipData: [],
                });
            }
        }
    }
    return {
        options,
        hasMore: !((data?.page ?? 0) >= (data?.totalPages ?? 0)),
    };
};
